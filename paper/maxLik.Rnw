\documentclass[smallextended,natbib]{svjour3}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{mathptmx}
\usepackage{textcomp}
\usepackage{url}
\usepackage{amsmath}
\usepackage{Sweave}
\usepackage{bm}
\smartqed

\newcommand{\code}[1]{\texttt{#1}}
\setlength{\emergencystretch}{3em}

\journalname{Computational Statistics}

\begin{document}

\title{maxLik: A Package for Maximum Likelihood Estimation in \textsf{R}}

\titlerunning{maxLik: Maximum Likelihood Estimation}

\author{Ott Toomet \and Arne Henningsen}

\institute{Ott Toomet \at
   Department of Economics, University of Tartu (Estonia)\\
   Department of Economics, Aarhus School of Business,
      University of Aarhus (Denmark)\\
\and
   Arne Henningsen \at
   Institute of Food and Resource Economics\\
   University of Copenhagen\\
   Rolighedsvej 25\\
   1958 Frederiksberg C, Denmark\\
   Tel.: +45-353-32274\\
   \email{arne@foi.dk}
}

\date{Received: date / Accepted: date}

\maketitle

\begin{abstract}
Insert your abstract here.
\keywords{Maximum Likelihood \and Optimisation}
\end{abstract}


\section{Introduction}

The Maximum Likelihood (ML) method is one of the most important
techniques in statistics and econometrics.
Most statistical and econometric software packages include
ready-made routines for maximum likelihood estimations
of many standard models such as logit, probit, sample-selection,
count-data, or survival models.
However, if practitioners and researchers want to estimate
non-standard models or develop new models,
they have to implement the routines
for the maximum likelihood estimations themselves.
In this case, the \textbf{maxLik} package~\citep{r-maxlik-0.5}
for the statistical software environment \textsf{R} \citep{r-project09}
might be very helpful.
Furthermore, developers that implement routines for maximum likelihood
estimations of specific models,
can save time and lines of code by using the \textbf{maxLik} package.
The \textbf{maxLik} package is available from
CRAN (\url{http://cran.r-project.org/package=maxLik}),
R-Forge (\url{http://r-forge.r-project.org/projects/maxlik/}), and its
homepage (\url{http://www.maxLik.org/}).


\section{Using the \textbf{maxLik} package}

We demonstrate the usage of the \textbf{maxLik} package by a simple example:
we fit a normal distribution by maximum likelihood.
First, we generate a vector ($x$) of 100 draws
from a normal distribution with a mean of $\mu = 1$
and a standard deviation of~$\sigma = 2$:
<<echo=FALSE,results=hide>>=
set.seed( 123 )
@
<<>>=
x <- rnorm( 100, mean = 1, sd = 2 )
@
%
The probability density function of a standard normal distribution
for a value $x_i$ is
\begin{equation}
P(x_i) =
\frac{1}{\sigma \sqrt{2 \pi}}
\exp \left( - \frac{( x_i - \mu )^2}{2 \sigma^2} \right).
\end{equation}
Hence, the likelihood function for $\mu$, $\sigma$,
and the values in vector $x = ( x_1, \ldots, x_N )$ is
\begin{equation}
L( x, \mu, \sigma ) = \prod_{i=1}^N
\frac{1}{\sigma \sqrt{2 \pi}}
\exp \left( - \frac{( x_i - \mu )^2}{2 \sigma^2} \right)
\end{equation}
and its logarithm (i.e.\ the log-likelihood function) is
\begin{equation}
\log( L( x, \mu, \sigma ) ) =
- \frac{1}{2} N \log ( 2 \pi ) - N \log ( \sigma )
- \frac{1}{2} \sum_{i=1}^N \frac{( x_i - \mu )^2}{\sigma^2}.
\end{equation}

As a prerequisite for the maximum likelihood estimation,
we have to implement the log-likelihood function in \textsf{R}.
Its first argument must be the vector of the parameters to be estimated
and it must return the log-likelihood value.%
\footnote{
Alternatively, it could return a numeric vector
where each component is the log-likelihood value
corresponding to an individual observations (see below).
}
<<>>=
logLikFun <- function( param ) {
   mu <- param[ 1 ]
   sigma <- param[ 2 ]
   N <- length( x )
   logLikValue <- -0.5 * N * log( 2 * pi ) - N * log( sigma ) -
      0.5 * sum( ( x - mu )^2 / sigma^2 )
   return( logLikValue )
}
@
The \textbf{maxLik} package must be installed and loaded
before it can be used.
The following command loads the \textbf{maxLik} package.
<<>>=
library( maxLik )
@
Now, we can use the \code{maxLik} functionn ---
the most important user interface
of the \textbf{maxLik} package ---
to find the values for the $\mu$ and $\beta$ parameters
that give the best fit, i.e.\ the largest value of the (log-)
likelihood function.
The first argument of \code{maxLik} (\code{logLik})
is mandatory and specifies the log-likelihood function.
Starting values must be provided through argument \code{start}.
In our examples, we use the parameters of a standard normal distribution
($\mu = 0$, $\sigma = 1$) as starting values.
<<>>=
mle <- maxLik( logLik = logLikFun, start = c( mu = 0,  sigma = 1 ) )
summary( mle )
@
As expected, the estimated parameters are equal to the mean
and the standard deviation (without correction for degrees of freedom)
of the values in vector~$x$.
<<>>=
mean( x )
sqrt( sum( ( x - mean( x ) )^2 ) / 100 )
@

If no analytical gradients are provided by the user,
numerical gradients and numerical Hessians are calculated
by the functions \code{numericGradient} and \code{numericNHessian},
which are also included in the \textbf{maxLik} package.
While the maximisation of the likelihood function of this simple model
works well with numerical gradients and Hessians,
providing analytical gradients could increase the speed and probability
of convergence in more complex models.
The gradients of the log-likelihood function of the standard normal distribution
are
\begin{align}
\frac{\partial \log( L( x, \mu, \sigma ) )}{ \partial \mu } & =
   \sum_{i=1}^N \frac{( x_i - \mu )}{\sigma^2}\\
\frac{\partial \log( L( x, \mu, \sigma ) )}{ \partial \sigma } & =
   - \frac{ N }{ \sigma }
   + \sum_{i=1}^N \frac{( x_i - \mu )^2}{\sigma^3}.
\end{align}
These gradients are calculated in \textsf{R} by following function:
<<>>=
logLikGrad <- function( param ) {
   mu <- param[ 1 ]
   sigma <- param[ 2 ]
   N <- length( x )
   logLikGradValues <- numeric( 2 )
   logLikGradValues[ 1 ] <- sum( ( x - mu ) / sigma^2 )
   logLikGradValues[ 2 ] <- - N / sigma + sum( ( x - mu )^2 / sigma^3 )
   return( logLikGradValues )
}
@
Now we call the \code{maxLik} function and use argument \code{grad}
to specify the function that calculates the gradients:
<<>>=
mleGrad <- maxLik( logLik = logLikFun, grad = logLikGrad,
   start = c( mu = 0, sigma = 1 ) )
summary( mleGrad )
@
Providing analytical gradients has no (visible) effect on the estimates
but the standard errors are slightly different.

The user can use argument \code{hess} of the \code{maxLik} function
to provide a function that returns the Hessian matrix
of the log-likelihood function.
If the user provides a function to calculate the gradients
but does not use argument \code{hess},
the Hessians are calculated numerically by the function
\code{numericHessian}.
The elements of the Hessian matrix of the log-likelihood function
of the normal distribution are
\begin{align}
\frac{\partial^2 \log( L( x, \mu, \sigma ) )}{ ( \partial \mu )^2 } & =
   - \frac{ N }{\sigma^2}\\
\frac{\partial^2 \log( L( x, \mu, \sigma ) )}{ \partial \mu \; \partial \sigma } & =
   - 2 \sum_{i=1}^N \frac{( x_i - \mu )}{\sigma^3}\\
\frac{\partial^2 \log( L( x, \mu, \sigma ) )}{ ( \partial \sigma )^2 } & =
   \frac{ N }{ \sigma^2 }
   - 3 \sum_{i=1}^N \frac{( x_i - \mu )^2}{\sigma^4}.
\end{align}
They can be calculated in \textsf{R} using the following function:
<<>>=
logLikHess <- function( param ) {
   mu <- param[ 1 ]
   sigma <- param[ 2 ]
   N <- length( x )
   logLikHessValues <- matrix( 0, nrow = 2, ncol = 2 )
   logLikHessValues[ 1, 1 ] <- - N / sigma^2
   logLikHessValues[ 1, 2 ] <-  - 2 * sum( ( x - mu ) / sigma^3 )
   logLikHessValues[ 2, 1 ] <- logLikHessValues[ 1, 2 ]
   logLikHessValues[ 2, 2 ] <- N / sigma^2 - 3 * sum( ( x - mu )^2 / sigma^4 )
   return( logLikHessValues )
}
@
Now we call the \code{maxLik} function with argument \code{hess}
set to this function:
<<>>=
mleHess <- maxLik( logLik = logLikFun, grad = logLikGrad,
   hess = logLikHess, start = c( mu = 0, sigma = 1 ) )
summary( mleHess )
all.equal( mleHess, mleGrad )
@
Providing an analytical Hessian has no significant effect
on the outcome of the ML estimation in our simple example.%
\footnote{%
\code{all.equal} considers two elements as equal
if either the mean absolute difference or the mean relative difference
are smaller than the tolerance
(defaults to \code{.Machine\$double.eps\^{ }0.5},
usually around \Sexpr{round(.Machine[["double.eps"]]^0.5,9)}).
}

\subsection{Optimisation Methods}

Currently, the user can use argument \code{method} to choose between
five different optimisation algorithms.
Argument \code{method} defaults to
\code{"NR"} for the Newton-Raphson algorithm, but it can be also
\code{"BHHH"} for Berndt-Hall-Hall-Hausman \citep{berndt74},
\code{"BFGS"} for Broyden-Fletcher-Goldfarb-Shanno
\citep{broyden70,fletcher70,goldfarb70,shanno70},
\code{"NM"} for Nelder-Mead \citep{nelder65}, or
\code{"SANN"} for simulated-annealing \citep{belisle92}.


\section{Implementation}

The \code{maxLik} function delegates the actual optimisation
to the functions
\code{maxNR}, \code{maxBHHH}, \code{maxBFGS}, \code{maxNM}, and
\code{maxSANN},
for the ``NR'', ``BHHH'', ``BFGS'', ``NM'', and ``SANN'' algorithms,
respectively.
While the actual optimisation in
\code{maxBFGS}, \code{maxNM}, and \code{maxSANN}
is done by \code{optim},
the Newton-Raphson algorithm is implemented
in the function \code{maxNR} itself.
The actual optimisation in \code{maxBHHH}
is done by \code{maxNR}.

The \code{maxLik}
wrapper capabilities are designed in a transparent way, so that the
user can easily swap the methods without changing the
arguments.  The arguments not used by a particular optimisation
method, such as \code{hess} for the Berndt-Hall-Hall-Hausman method,
are ignored.


The \textbf{maxLik} package is implemented using S3 classes.
The \code{maxLik} wrapper returns a list of class \code{"maxLik"}.
Corresponding methods can handle the likelihood-specific properties
of the estimate including the fact
that the inverse of the negative Hessian is the variance-covariance matrix
of the estimated parameters.
The most important methods for objects of class \code{"maxLik"} are:
\code{summary} for returning (and printing) summary results,
\code{coef} for extracting the estimated parameters,
\code{vcov} for calculating the variance covariance matrix
of the estimated parameters,
\code{logLik} for extracting the log-likelihood value, and
\code{AIC} for calculating the Akaike information criterion.

Currently, the \textbf{maxLik} package is used for maximum likelihood
estimations in three \textsf{R} packages that are available on CRAN:
\textbf{mlogit}, \textbf{sampleSelection},
and \textbf{truncreg}.
On the DSC conference,
we would like to demonstrate the implementation and the usage
of the \textbf{maxLik} package.
Furthermore, we want to discuss future improvements and features
with other participants
in order to make the \textbf{maxLik} package more attractive
to users and package writers.

%\begin{acknowledgements}
%\end{acknowledgements}

\bibliographystyle{spbasic}
% \bibliography{agrarpol}
\bibliography{references}

\end{document}
